"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[3459,7644,2970,8454],{3905:(e,t,i)=>{i.d(t,{Zo:()=>c,kt:()=>p});var n=i(67294);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function s(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?s(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):s(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function o(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)i=s[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)i=s[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var d=n.createContext({}),l=function(e){var t=n.useContext(d),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},c=function(e){var t=l(e.components);return n.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var i=e.components,a=e.mdxType,s=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=l(i),p=a,g=u["".concat(d,".").concat(p)]||u[p]||m[p]||s;return i?n.createElement(g,r(r({ref:t},c),{},{components:i})):n.createElement(g,r({ref:t},c))}));function p(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=i.length,r=new Array(s);r[0]=u;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var l=2;l<s;l++)r[l]=i[l];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}u.displayName="MDXCreateElement"},50358:(e,t,i)=>{i.d(t,{Z:()=>d});var n=i(67294),a=i(52263);const s="authorByline_VoxI",r="authorLabel_a70t",o="authorProfileImage_URwT";const d=function(e){let{frontMatter:t}=e;const{siteConfig:i}=(0,a.Z)(),d=i.customFields.authors;return n.createElement(n.Fragment,null,t.authors&&n.createElement("div",{className:"docAuthors"},n.createElement("hr",null),t.authors.map((e=>n.createElement("div",{key:e,className:s},n.createElement("img",{className:o,src:`/img/${d[e].image?d[e].image:"default_author_profile_pic.png"}`,alt:`Profile picture for ${d[e].name}`}),n.createElement("div",null,n.createElement("div",{className:r},"Author:"),n.createElement("div",null,n.createElement("a",{href:d[e].link,target:"_blank"},d[e].name),", ",d[e].title))))),n.createElement("hr",null)))}},34795:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=i(87462),a=(i(67294),i(3905));const s={},r=void 0,o={unversionedId:"howtos/solutions/fraud-detection/common-fraud/source-code-tip",id:"howtos/solutions/fraud-detection/common-fraud/source-code-tip",title:"source-code-tip",description:"Below is a command to the clone the source code for the application used in this tutorial",source:"@site/docs/howtos/solutions/fraud-detection/common-fraud/source-code-tip.mdx",sourceDirName:"howtos/solutions/fraud-detection/common-fraud",slug:"/howtos/solutions/fraud-detection/common-fraud/source-code-tip",permalink:"/howtos/solutions/fraud-detection/common-fraud/source-code-tip",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/fraud-detection/common-fraud/source-code-tip.mdx",tags:[],version:"current",lastUpdatedAt:1680952345,formattedLastUpdatedAt:"Apr 8, 2023",frontMatter:{}},d={},l=[],c={toc:l};function m(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"GITHUB CODE",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Below is a command to the clone the source code for the application used in this tutorial"),(0,a.kt)("p",{parentName:"admonition"},"git clone --branch v3.0.0 ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"},"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"))))}m.isMDXComponent=!0},34260:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>p,contentTitle:()=>m,default:()=>y,frontMatter:()=>c,metadata:()=>u,toc:()=>g});var n=i(87462),a=(i(67294),i(3905)),s=i(50358);const r=i.p+"assets/images/digital-identity-a6be57e70c17b27f715960fdf32522d8.png";var o=i(34795),d=i(4975),l=i(34045);const c={id:"index-digital-identity-validation",title:"How to Handle Digital Identity Validation Using Redis",sidebar_label:"Redis for Digital Identity Validation",slug:"/howtos/solutions/fraud-detection/digital-identity-validation",authors:["prasan","will"]},m=void 0,u={unversionedId:"howtos/solutions/fraud-detection/digital-identity-validation/index-digital-identity-validation",id:"howtos/solutions/fraud-detection/digital-identity-validation/index-digital-identity-validation",title:"How to Handle Digital Identity Validation Using Redis",description:"Digital identity validation for fraud detection introduction",source:"@site/docs/howtos/solutions/fraud-detection/digital-identity-validation/index-digital-identity-validation.mdx",sourceDirName:"howtos/solutions/fraud-detection/digital-identity-validation",slug:"/howtos/solutions/fraud-detection/digital-identity-validation",permalink:"/howtos/solutions/fraud-detection/digital-identity-validation",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/fraud-detection/digital-identity-validation/index-digital-identity-validation.mdx",tags:[],version:"current",lastUpdatedAt:1700152680,formattedLastUpdatedAt:"Nov 16, 2023",frontMatter:{id:"index-digital-identity-validation",title:"How to Handle Digital Identity Validation Using Redis",sidebar_label:"Redis for Digital Identity Validation",slug:"/howtos/solutions/fraud-detection/digital-identity-validation",authors:["prasan","will"]},sidebar:"docs",previous:{title:"How to use Redis for API Gateway Caching",permalink:"/howtos/solutions/microservices/api-gateway-caching"},next:{title:"How to use Redis for Transaction risk scoring",permalink:"/howtos/solutions/fraud-detection/transaction-risk-scoring"}},p={},g=[{value:"Digital identity validation for fraud detection introduction",id:"digital-identity-validation-for-fraud-detection-introduction",level:2},{value:"Know Your Customer (KYC)",id:"know-your-customer-kyc",level:2},{value:"What is digital identity?",id:"what-is-digital-identity",level:2},{value:"Why you should use redis for digital identity validation",id:"why-you-should-use-redis-for-digital-identity-validation",level:2},{value:"Microservices architecture for an E-commerce Application",id:"microservices-architecture-for-an-e-commerce-application",level:2},{value:"Storing digital identities",id:"storing-digital-identities",level:3},{value:"Validating digital identities",id:"validating-digital-identities",level:3},{value:"E-commerce application frontend using Next.js and Tailwind",id:"e-commerce-application-frontend-using-nextjs-and-tailwind",level:2},{value:"Building a digital identity validation microservice with redis",id:"building-a-digital-identity-validation-microservice-with-redis",level:2},{value:"Storing digital identities in redis in a microservices architecture",id:"storing-digital-identities-in-redis-in-a-microservices-architecture",level:3},{value:"Validating digital identities using redis in a microservices architecture",id:"validating-digital-identities-using-redis-in-a-microservices-architecture",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Additional Resources",id:"additional-resources",level:3}],h={toc:g};function y(e){let{components:t,...m}=e;return(0,a.kt)("wrapper",(0,n.Z)({},h,m,{components:t,mdxType:"MDXLayout"}),(0,a.kt)(s.Z,{frontMatter:c,mdxType:"Authors"}),(0,a.kt)(o.default,{mdxType:"SourceCodeFraudDetection"}),(0,a.kt)("h2",{id:"digital-identity-validation-for-fraud-detection-introduction"},"Digital identity validation for fraud detection introduction"),(0,a.kt)("p",null,"As the digital landscape continues to evolve, the need for robust security measures to protect users and organizations becomes ever more critical. Digital identity validation and fraud detection are essential components of any comprehensive security plan. This article will explore the significance of digital identity validation, the challenges faced in this area, and a solution to digital identity validation using redis."),(0,a.kt)("h2",{id:"know-your-customer-kyc"},"Know Your Customer (KYC)"),(0,a.kt)("p",null,'"Know Your Customer" (KYC) regulations refer to a set of policies and procedures that financial institutions and other regulated businesses must follow to verify the identity of their customers. Customer details can be like name, address, date of birth, and other government-issued identification documents.'),(0,a.kt)("p",null,"As part of KYC, businesses must assess the potential risk posed by each customer and conduct ",(0,a.kt)("strong",{parentName:"p"},"ongoing monitoring")," of their transactions and behaviour to detect any suspicious activity. KYC regulations are enforced by regulatory authorities, and failure to comply can result in financial penalties and reputation damage."),(0,a.kt)("p",null,"KYC regulations are intended to prevent money laundering, terrorist financing, and other illicit activities. Financial services companies are combating the use of stolen identity information by reducing reliance on static methods for verifying identity (Knowledge-Based Authentication, or KBA) and instead moving to digital identities."),(0,a.kt)("h2",{id:"what-is-digital-identity"},"What is digital identity?"),(0,a.kt)("p",null,"Digital identity refers to the collection of attributes and identifiers that represent an individual online. These may include names, email addresses, phone numbers, usernames, and biometrics, among others. Digital identity validation is the process of verifying that these attributes are accurate and belong to the entity they claim to represent."),(0,a.kt)("p",null,"Identity validation is crucial because it helps establish trust in digital environments, where face-to-face interaction is often not possible. It ensures that the parties involved in a transaction are who they claim to be, minimizing the risk of fraud, identity theft, and other cyber crimes."),(0,a.kt)("img",{src:r,alt:"Digital Identity attributes",width:"500",className:"margin-bottom--md"}),(0,a.kt)("p",null,"Digital identities consist of two parts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Static")," data: personally identifiable information (PII) such as name, address, and biometrics"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Dynamic")," data: behavioural and contextual information such as browsing history, device type, and location data. Dynamic digital identities are constantly updated based on the information available from each digital transaction.")),(0,a.kt)("p",null,"Companies must monitor customer's every transaction and behaviour, then use stored digital identities to score the ",(0,a.kt)("strong",{parentName:"p"},"risk"),", identifying ",(0,a.kt)("strong",{parentName:"p"},"possible suspicious activity")," for a given transaction."),(0,a.kt)("h2",{id:"why-you-should-use-redis-for-digital-identity-validation"},"Why you should use redis for digital identity validation"),(0,a.kt)("p",null,"The following are the primary requirements of a storage layer for digital identities:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Must maintain ",(0,a.kt)("strong",{parentName:"li"},"real-time read latency")," to fit within transaction SLA."),(0,a.kt)("li",{parentName:"ul"},"Must have a ",(0,a.kt)("strong",{parentName:"li"},"flexible data model")," to store multiple unstructured data types such as behavioural, transactional, location, social/mobile and more.")),(0,a.kt)("p",null,"These two factors are limiting for using traditional Relation Database Management Systems (RDBMS) to manage and validate digital identities in real time. While it is possible to use RDBMS to store digital identities, it is not the best choice for real-time validation of a flexible data model."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Redis Cloud"),", on the other hand, is optimized for high throughput, low latency, data flexibility, and real-time query performance, easily satisfying the first criterion. With ",(0,a.kt)("strong",{parentName:"p"},"sub-millisecond latency")," and hundreds of millions of operations per second across both read and write operations, it is well-suited for managing dynamic digital identity data. As the volume of data grows, we can expect near-linear scalability and 99.999% of uptime with ",(0,a.kt)("strong",{parentName:"p"},"Active-Active geo-replication"),"."),(0,a.kt)("p",null,"Redis Cloud's flexible data model has native support for multiple data types, including ",(0,a.kt)("strong",{parentName:"p"},"JSON, hashes, streams, graphs and more"),". Additionally, it can process complex searches on structured and unstructured data, as well as filtering by numeric properties and geographical distances, making it easier to manage and query large datasets of digital identities."),(0,a.kt)("h2",{id:"microservices-architecture-for-an-e-commerce-application"},"Microservices architecture for an E-commerce Application"),(0,a.kt)(l.default,{mdxType:"MicroservicesArchitectureWithRedis"}),(0,a.kt)("h3",{id:"storing-digital-identities"},"Storing digital identities"),(0,a.kt)("p",null,"Given we're discussing a microservices application, it makes sense to use a microservice for managing digital identities. Consider the following workflow outlining how digital identities are stored and retrieved from redis:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"digital-identity-code-flow-01",src:i(46706).Z,width:"1600",height:"864"})),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The demo application doesn't have a ",(0,a.kt)("inlineCode",{parentName:"p"},"login service"),". All user sessions are currently authenticated in the ",(0,a.kt)("inlineCode",{parentName:"p"},"api gateway")," service. So ",(0,a.kt)("inlineCode",{parentName:"p"},"login service")," is synonymous with the ",(0,a.kt)("inlineCode",{parentName:"p"},"api gateway")," with respect to the demo app.")),(0,a.kt)("p",null,"The demo application uses redis streams for interservice communication. The following outlines the workflow, and the responsibilities of each service:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"login service"),": stores the (user) digital identity as a ",(0,a.kt)("inlineCode",{parentName:"li"},"INSERT_LOGIN_IDENTITY")," stream entry to redis\n",(0,a.kt)("img",{alt:"Login Identity in Transaction Stream",src:i(99491).Z,width:"2448",height:"928"})),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"digital identity service"),": reads the identity from the ",(0,a.kt)("inlineCode",{parentName:"li"},"INSERT_LOGIN_IDENTITY")," stream"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"digital identity service"),": stores the identity as JSON to redis\n",(0,a.kt)("img",{alt:"Login Identity as JSON",src:i(95057).Z,width:"1444",height:"778"}))),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"For demo purposes, we are only using a few characteristics of a user's digital identity like IP address, browser fingerprint, and session. In a real-world application you should store more characteristics like location, device type, and prior actions taken for better risk assessment and identity completeness.")),(0,a.kt)("h3",{id:"validating-digital-identities"},"Validating digital identities"),(0,a.kt)("p",null,"In an e-commerce application, validating digital identities happens at checkout time. You want to make sure the customer is who they say they are before you attempt to process their order. To validate digital identities, we need to calculate the digital identity score, starting in the ",(0,a.kt)("inlineCode",{parentName:"p"},"orders service"),". The following outlines the workflow, and the responsibilities of each service:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"digital-identity-code-flow-02",src:i(78298).Z,width:"1865",height:"887"})),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"orders service"),": stores the digital identity in a ",(0,a.kt)("inlineCode",{parentName:"li"},"CALCULATE_IDENTITY_SCORE")," redis stream event to calculate it's identity score\n",(0,a.kt)("img",{alt:"Validation Identity in Transaction Stream",src:i(85501).Z,width:"2374",height:"920"})),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"digital identity service"),": reads the identity from the ",(0,a.kt)("inlineCode",{parentName:"li"},"CALCULATE_IDENTITY_SCORE")," stream event"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"digital identity service"),": stores the identity with its calculated score as JSON\n",(0,a.kt)("img",{alt:"Validation Identity as JSON",src:i(54898).Z,width:"1372",height:"814"}))),(0,a.kt)("admonition",{title:"Caveat",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Even though you may receive a score of \u201c1\u201d this only means the score has matched 100% against the measured properties only. We are only measuring digital aspects of the identity, which can be compromised. In a real-world scenario you would want to measure more characteristics like location, device type, session, etc. This is in addition to other contextual information for a complete ",(0,a.kt)("u",null,(0,a.kt)("a",{parentName:"p",href:"/howtos/solutions/fraud-detection/transaction-risk-scoring"},"transaction risk score")),".")),(0,a.kt)("h2",{id:"e-commerce-application-frontend-using-nextjs-and-tailwind"},"E-commerce application frontend using Next.js and Tailwind"),(0,a.kt)(d.default,{mdxType:"MicroservicesEcommerceDesign"}),(0,a.kt)(o.default,{mdxType:"SourceCodeFraudDetection"}),(0,a.kt)("h2",{id:"building-a-digital-identity-validation-microservice-with-redis"},"Building a digital identity validation microservice with redis"),(0,a.kt)("p",null,"Now, let's go step-by-step through the process of storing, scoring, and validating digital identities using redis with some example code. For demo purposes, we are only using a few characteristics of a user's digital identity like IP address, browser fingerprint, and session. In a real-world application you should store more characteristics like location, device type, and prior actions taken for better risk assessment and identity completeness."),(0,a.kt)("h3",{id:"storing-digital-identities-in-redis-in-a-microservices-architecture"},"Storing digital identities in redis in a microservices architecture"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"login service"),": stores the (user) digital identity as a ",(0,a.kt)("inlineCode",{parentName:"li"},"INSERT_LOGIN_IDENTITY")," stream entry to redis")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"//addLoginToTransactionStream\nconst userId = 'USR_4e7acc44-e91e-4c5c-9112-bdd99d799dd3'; //from session\nconst sessionId = 'SES_94ff24a8-65b5-4795-9227-99906a43884e'; //from session\nconst persona = 'GRANDFATHER'; //from session\n\nconst entry: ITransactionStreamMessage = {\n  action: TransactionStreamActions.INSERT_LOGIN_IDENTITY,\n  logMessage: `[${REDIS_STREAMS.CONSUMERS.IDENTITY}] Digital identity to be stored for the user ${userId}`,\n  userId,\n  persona,\n  sessionId,\n\n  identityBrowserAgent: req.headers['user-agent'],\n  identityIpAddress:\n    req.headers['x-forwarded-for']?.toString() || req.socket.remoteAddress,\n  transactionPipeline: JSON.stringify(TransactionPipelines.LOGIN),\n};\n\nconst nodeRedisClient = getNodeRedisClient();\nconst streamKeyName = 'TRANSACTION_STREAM';\nconst id = '*'; //* = auto generate\nawait nodeRedisClient.xAdd(streamKeyName, id, entry);\n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"digital identity service"),": reads the identity from the ",(0,a.kt)("inlineCode",{parentName:"li"},"INSERT_LOGIN_IDENTITY")," stream")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ListenStreamOptions {\n  streams: {\n    streamKeyName: string;\n    eventHandlers: {\n      [messageAction: string]: IMessageHandler;\n    };\n  }[];\n  groupName: string;\n  consumerName: string;\n  maxNoOfEntriesToReadAtTime?: number;\n}\n\n// Below is some code for how you would use redis to listen for the stream events:\n\nconst listenToStreams = async (options: ListenStreamOptions) => {\n  /*\n   (A) create consumer group for the stream\n   (B) read set of messages from the stream\n   (C) process all messages received\n   (D) trigger appropriate action callback for each message\n   (E) acknowledge individual messages after processing\n  */\n  const nodeRedisClient = getNodeRedisClient();\n  if (nodeRedisClient) {\n    const streams = options.streams;\n    const groupName = options.groupName;\n    const consumerName = options.consumerName;\n    const readMaxCount = options.maxNoOfEntriesToReadAtTime || 100;\n    const idInitialPosition = '0'; //0 = start, $ = end or any specific id\n    const streamKeyIdArr: {\n      key: string;\n      id: string;\n    }[] = [];\n\n    streams.map(async (stream) => {\n      LoggerCls.info(\n        `Creating consumer group ${groupName} in stream ${stream.streamKeyName}`,\n      );\n\n      try {\n        // (A) create consumer group for the stream\n        await nodeRedisClient.xGroupCreate(\n          stream.streamKeyName,\n          groupName,\n          idInitialPosition,\n          {\n            MKSTREAM: true,\n          },\n        );\n      } catch (err) {\n        LoggerCls.error(\n          `Consumer group ${groupName} already exists in stream ${stream.streamKeyName}!`,\n        );\n      }\n\n      streamKeyIdArr.push({\n        key: stream.streamKeyName,\n        id: '>', // Next entry ID that no consumer in this group has read\n      });\n    });\n\n    LoggerCls.info(`Starting consumer ${consumerName}.`);\n\n    while (true) {\n      try {\n        // (B) read set of messages from different streams\n        const dataArr = await nodeRedisClient.xReadGroup(\n          commandOptions({\n            isolated: true,\n          }),\n          groupName,\n          consumerName,\n          //can specify multiple streams in array [{key, id}]\n          streamKeyIdArr,\n          {\n            COUNT: readMaxCount, // Read n entries at a time\n            BLOCK: 5, //block for 0 (infinite) seconds if there are none.\n          },\n        );\n\n        // dataArr = [\n        //   {\n        //     name: 'streamName',\n        //     messages: [\n        //       {\n        //         id: '1642088708425-0',\n        //         message: {\n        //           key1: 'value1',\n        //         },\n        //       },\n        //     ],\n        //   },\n        // ];\n\n        //(C) process all messages received\n        if (dataArr && dataArr.length) {\n          for (let data of dataArr) {\n            for (let messageItem of data.messages) {\n              const streamKeyName = data.name;\n\n              const stream = streams.find(\n                (s) => s.streamKeyName == streamKeyName,\n              );\n\n              if (stream && messageItem.message) {\n                const streamEventHandlers = stream.eventHandlers;\n                const messageAction = messageItem.message.action;\n                const messageHandler = streamEventHandlers[messageAction];\n\n                if (messageHandler) {\n                  // (D) trigger appropriate action callback for each message\n                  await messageHandler(messageItem.message, messageItem.id);\n                }\n                //(E) acknowledge individual messages after processing\n                nodeRedisClient.xAck(streamKeyName, groupName, messageItem.id);\n              }\n            }\n          }\n        } else {\n          // LoggerCls.info('No new stream entries.');\n        }\n      } catch (err) {\n        LoggerCls.error('xReadGroup error !', err);\n      }\n    }\n  }\n};\n\n// `listenToStreams` listens for events and calls the appropriate callback to further handle the events.\nlistenToStreams({\n  streams: [\n    {\n      streamKeyName: REDIS_STREAMS.STREAMS.TRANSACTIONS,\n      eventHandlers: {\n        [TransactionStreamActions.INSERT_LOGIN_IDENTITY]: insertLoginIdentity,\n        //...\n      },\n    },\n  ],\n  groupName: REDIS_STREAMS.GROUPS.IDENTITY,\n  consumerName: REDIS_STREAMS.CONSUMERS.IDENTITY,\n});\n")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"digital identity service"),": stores the identity as JSON to redis")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const insertLoginIdentity: IMessageHandler = async (\n  message: ITransactionStreamMessage,\n  messageId,\n) => {\n  LoggerCls.info(`Adding digital identity to redis for ${message.userId}`);\n\n  // add login digital identity to redis\n  const insertedKey = await addDigitalIdentityToRedis(message);\n\n  //...\n};\n\nconst addDigitalIdentityToRedis = async (\n  message: ITransactionStreamMessage,\n) => {\n  let insertedKey = '';\n\n  const userId = message.userId;\n  const digitalIdentity: IDigitalIdentity = {\n    action: message.action,\n    userId: userId,\n    sessionId: message.sessionId,\n\n    ipAddress: message.identityIpAddress,\n    browserFingerprint: crypto\n      .createHash('sha256')\n      .update(message.identityBrowserAgent)\n      .digest('hex'),\n    identityScore: message.identityScore ? message.identityScore : '',\n\n    createdOn: new Date(),\n    createdBy: userId,\n    statusCode: DB_ROW_STATUS.ACTIVE,\n  };\n\n  const repository = digitalIdentityRepo.getRepository();\n  if (repository) {\n    const entity = repository.createEntity(digitalIdentity);\n    insertedKey = await repository.save(entity);\n  }\n\n  return insertedKey;\n};\n")),(0,a.kt)("h3",{id:"validating-digital-identities-using-redis-in-a-microservices-architecture"},"Validating digital identities using redis in a microservices architecture"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"orders service"),": stores the digital identity to be validated in a ",(0,a.kt)("inlineCode",{parentName:"li"},"CALCULATE_IDENTITY_SCORE")," redis stream")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"//adding Identity To TransactionStream\nconst userId = 'USR_4e7acc44-e91e-4c5c-9112-bdd99d799dd3';\nconst sessionId = 'SES_94ff24a8-65b5-4795-9227-99906a43884e';\nlet orderDetails = {\n  orderId: '63f5f8dc3696d145a45775a6',\n  orderAmount: '1000',\n  userId: userId,\n  sessionId: sessionId,\n  orderStatus: 1,\n  products: order.products, //array of product details\n};\n\nconst entry: ITransactionStreamMessage = {\n  action: 'CALCULATE_IDENTITY_SCORE',\n  logMessage: `Digital identity to be validated/ scored for the user ${userId}`,\n  userId: userId,\n  sessionId: sessionId,\n  orderDetails: orderDetails ? JSON.stringify(orderDetails) : '',\n  transactionPipeline: JSON.stringify(TransactionPipelines.CHECKOUT),\n\n  identityBrowserAgent: req.headers['user-agent'],\n  identityIpAddress:\n    req.headers['x-forwarded-for']?.toString() || req.socket.remoteAddress,\n};\n\nconst nodeRedisClient = getNodeRedisClient();\nconst streamKeyName = 'TRANSACTION_STREAM';\nconst id = '*'; //* = auto generate\nawait nodeRedisClient.xAdd(streamKeyName, id, entry);\n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Digital identity service")," reads the identity from the ",(0,a.kt)("inlineCode",{parentName:"li"},"CALCULATE_IDENTITY_SCORE")," stream")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"listenToStreams({\n  streams: [\n    {\n      streamKeyName: REDIS_STREAMS.STREAMS.TRANSACTIONS,\n      eventHandlers: {\n        // ...\n        [TransactionStreamActions.CALCULATE_IDENTITY_SCORE]:\n          scoreDigitalIdentity,\n      },\n    },\n  ],\n  groupName: REDIS_STREAMS.GROUPS.IDENTITY,\n  consumerName: REDIS_STREAMS.CONSUMERS.IDENTITY,\n});\n\nconst scoreDigitalIdentity: IMessageHandler = async (\n  message: ITransactionStreamMessage,\n  messageId,\n) => {\n  LoggerCls.info(`Scoring digital identity for ${message.userId}`);\n\n  //step 1 - calculate score for validation digital identity\n  const identityScore = await calculateIdentityScore(message);\n  message.identityScore = identityScore.toString();\n\n  LoggerCls.info(`Adding digital identity to redis for ${message.userId}`);\n  //step 2 - add validation digital identity to redis\n  const insertedKey = await addDigitalIdentityToRedis(message);\n\n  // ...\n};\n\nconst calculateIdentityScore = async (message: ITransactionStreamMessage) => {\n  // Compare the \"digital identity\" with previously stored \"login identities\" and determine the identity score\n\n  let identityScore = 0;\n  const repository = digitalIdentityRepo.getRepository();\n\n  if (message && message.userId && repository) {\n    let queryBuilder = repository\n      .search()\n      .where('userId')\n      .eq(message.userId)\n      .and('action')\n      .eq('INSERT_LOGIN_IDENTITY')\n      .and('statusCode')\n      .eq(DB_ROW_STATUS.ACTIVE);\n\n    //console.log(queryBuilder.query);\n    const digitalIdentities = await queryBuilder.return.all();\n\n    if (digitalIdentities && digitalIdentities.length) {\n      //if browser details matches -> +1 score\n      const matchBrowserItems = digitalIdentities.filter((_digIdent) => {\n        let identityBrowserAgentHash = crypto\n          .createHash('sha256')\n          .update(message.identityBrowserAgent)\n          .digest('hex');\n        return _digIdent.browserFingerprint == identityBrowserAgentHash;\n      });\n      if (matchBrowserItems.length > 0) {\n        identityScore += 1;\n      }\n\n      //if IP address  matches -> +1 score\n      const matchIpAddressItems = digitalIdentities.filter((_digIdent) => {\n        return _digIdent.ipAddress == message.identityIpAddress;\n      });\n      if (matchIpAddressItems.length > 0) {\n        identityScore += 1;\n      }\n    }\n  }\n\n  //calculate average score\n  const noOfIdentityCharacteristics = 2; //2 == browserFingerprint, ipAddress\n  identityScore = identityScore / noOfIdentityCharacteristics;\n  return identityScore; // identityScore final value ranges between 0 (no match) and 1 (full match)\n};\n")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"digital identity service"),": stores the identity with score as JSON in redis")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const addDigitalIdentityToRedis = async (\n  message: ITransactionStreamMessage,\n) => {\n  let insertedKey = '';\n\n  const userId = message.userId;\n  const digitalIdentity: IDigitalIdentity = {\n    action: message.action,\n    userId: userId,\n    sessionId: message.sessionId,\n\n    ipAddress: message.identityIpAddress,\n    browserFingerprint: crypto\n      .createHash('sha256')\n      .update(message.identityBrowserAgent)\n      .digest('hex'),\n    identityScore: message.identityScore ? message.identityScore : '',\n\n    createdOn: new Date(),\n    createdBy: userId,\n    statusCode: DB_ROW_STATUS.ACTIVE, //1\n  };\n\n  const repository = digitalIdentityRepo.getRepository();\n  if (repository) {\n    const entity = repository.createEntity(digitalIdentity);\n    insertedKey = await repository.save(entity);\n  }\n\n  return insertedKey;\n};\n")),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,'Now you have learned how to use redis to setup ongoing digital identity monitoring and scoring in a microservices application. This is also called "dynamic digital identity monitoring." Dynamic digital identities are constantly updated based on the information available from each digital transaction. By analyzing these transactions, businesses can build a comprehensive and up-to-date digital identity that includes both static and dynamic elements. These identities can then be scored to determine the risk that they pose to the business.'),(0,a.kt)("p",null,"In addition to increasing security, digital identities can also improve the customer experience. By using the digital footprint left by a user, businesses can offer more personalized services and reduce friction in the authentication process."),(0,a.kt)("p",null,"Digital identity systems are typically designed to be interoperable and scalable, allowing for seamless integration with various applications and platforms."),(0,a.kt)("h3",{id:"additional-resources"},"Additional Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Redis Streams",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Explore streams in detail in the ",(0,a.kt)("a",{parentName:"li",href:"https://university.redis.com/courses/ru202/"},"Redis University course on Redis Streams")),(0,a.kt)("li",{parentName:"ul"},"Check out our e-book on ",(0,a.kt)("a",{parentName:"li",href:"https://redis.com/docs/understanding-streams-in-redis-and-kafka-a-visual-guide/"},"Understanding Streams in Redis and Kafka: A Visual Guide")))),(0,a.kt)("li",{parentName:"ul"},"Fraud detection with Redis",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/howtos/solutions/fraud-detection/transaction-risk-scoring"},"Transaction Risk Scoring")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/howtos/solutions#microservices"},"Microservices with Redis")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/c/Redisinc"},"Redis YouTube channel")),(0,a.kt)("li",{parentName:"ul"},"Clients like ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/redis/node-redis"},"Node Redis")," and ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/redis/redis-om-node"},"Redis om Node")," help you to use Redis in Node.js applications."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://redis.com/redis-enterprise/redis-insight/"},"RedisInsight")," : To view your Redis data or to play with raw Redis commands in the workbench"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://redis.com/try-free/"},"Try Redis Cloud for free"))))}y.isMDXComponent=!0},34045:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=i(87462),a=(i(67294),i(3905));const s={},r=void 0,o={unversionedId:"howtos/solutions/microservices/common-data/microservices-arch-with-redis",id:"howtos/solutions/microservices/common-data/microservices-arch-with-redis",title:"microservices-arch-with-redis",description:"The e-commerce microservices application discussed in the rest of this tutorial uses the following architecture:",source:"@site/docs/howtos/solutions/microservices/common-data/microservices-arch-with-redis.mdx",sourceDirName:"howtos/solutions/microservices/common-data",slug:"/howtos/solutions/microservices/common-data/microservices-arch-with-redis",permalink:"/howtos/solutions/microservices/common-data/microservices-arch-with-redis",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/microservices/common-data/microservices-arch-with-redis.mdx",tags:[],version:"current",lastUpdatedAt:1689359285,formattedLastUpdatedAt:"Jul 14, 2023",frontMatter:{}},d={},l=[],c={toc:l};function m(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The e-commerce microservices application discussed in the rest of this tutorial uses the following architecture:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"products service"),": handles querying products from the database and returning them to the frontend"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"orders service"),": handles validating and creating orders"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"order history service"),": handles querying a customer's order history"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"payments service"),": handles processing orders for payment"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"digital identity service"),": handles storing digital identity and calculating identity score"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"api gateway"),": unifies services under a single endpoint"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"mongodb/ postgresql"),": serves as the primary database, storing orders, order history, products, etc."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"redis"),": serves as the ",(0,a.kt)("strong",{parentName:"li"},"stream processor")," and caching database")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"You don't need to use MongoDB/ Postgresql as your primary database in the demo application; you can use other ",(0,a.kt)("u",null,(0,a.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/reference/database-reference/supported-databases"},"prisma supported databases"))," as well. This is just an example.")))}m.isMDXComponent=!0},4975:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=i(87462),a=(i(67294),i(3905));const s={},r=void 0,o={unversionedId:"howtos/solutions/microservices/common-data/microservices-ecommerce",id:"howtos/solutions/microservices/common-data/microservices-ecommerce",title:"microservices-ecommerce",description:"The e-commerce microservices application consists of a frontend, built using Next.js with TailwindCSS. The application backend uses Node.js. The data is stored in",source:"@site/docs/howtos/solutions/microservices/common-data/microservices-ecommerce.mdx",sourceDirName:"howtos/solutions/microservices/common-data",slug:"/howtos/solutions/microservices/common-data/microservices-ecommerce",permalink:"/howtos/solutions/microservices/common-data/microservices-ecommerce",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/microservices/common-data/microservices-ecommerce.mdx",tags:[],version:"current",lastUpdatedAt:1689359285,formattedLastUpdatedAt:"Jul 14, 2023",frontMatter:{}},d={},l=[],c={toc:l};function m(e){let{components:t,...s}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The e-commerce microservices application consists of a frontend, built using ",(0,a.kt)("a",{parentName:"p",href:"https://nextjs.org/"},"Next.js")," with ",(0,a.kt)("a",{parentName:"p",href:"https://tailwindcss.com/"},"TailwindCSS"),". The application backend uses ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org"},"Node.js"),". The data is stored in\n",(0,a.kt)("a",{parentName:"p",href:"https://redis.com/try-free/"},"Redis")," and MongoDB/ Postgressql using ",(0,a.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/reference/database-reference/supported-databases"},"Prisma"),". Below you will find screenshots of the frontend of the e-commerce app:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"Dashboard"),": Shows the list of products with search functionality"),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"redis microservices e-commerce app frontend products page",src:i(89628).Z,width:"2475",height:"1873"}))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"Shopping Cart"),': Add products to the cart, then check out using the "Buy Now" button\n',(0,a.kt)("img",{alt:"redis microservices e-commerce app frontend shopping cart",src:i(70114).Z,width:"2772",height:"1942"}))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"Order history"),": Once an order is placed, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Orders")," link in the top navigation bar shows the order status and history"),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"redis microservices e-commerce app frontend order history page",src:i(61032).Z,width:"2511",height:"1351"})))))}m.isMDXComponent=!0},99491:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/code-flow-1-1-04c5dd5adc272919d5affa6cf42f3b26.png"},95057:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/code-flow-1-3-da0a86b79b5e329583164e91f8c18547.png"},85501:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/code-flow-2-1-bf25eadb5be602c0f4f8ca887d91d5b6.png"},54898:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/code-flow-2-4-29cdcd9cfd86c1c59be8dc9930f019b3.png"},46706:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/digital-identity-code-flow-1-b31021706a3b1ff60158c58f8e306eb8.png"},78298:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/digital-identity-code-flow-2-db11e04074e472e9c9bda2314bffe3bd.png"},70114:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/design-cart-2-2a3b76656f26a754bed6a6c63ad8beef.png"},89628:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/design-dashboard-6a34137ca4862561cc2f065ed55ae081.png"},61032:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/design-order-history-16fc808f70b63d91a37a3ea76baa232d.png"}}]);